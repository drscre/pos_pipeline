package slides

import (
	"github.com/drscre/pos_pipeline/pipeline"
)

func declarePipeline() []pipeline.IStep {
	return []pipeline.IStep{

		// Сходить в PMS за customer id
		pipeline.Step(a(func(auth *Authorization) error { // <-- auth это наши "переменные стэка". Сохраняются атомарно в момент завершения шага без ошибки.

			customerID, _ := pms.GetCustomerID(auth.CardID)
			auth.CustomerID = customerID
			return nil

		})).
			Name("pms_customer_id"), // У каждого шага есть уникальное имя, чтобы можно было сохранить в БД какой последний шаг был выполнен
								     // (можно смотреть как на синтаксический сахар для "стейт-машины", где все шаги друг за другом)
	}

}

// В базе данных хранится контекcт выполнения пайплайна.
type State struct {
	ID                string      // Уникальный идентификатор пайплайна (пусть будет id авторизации). По нему берётся лок при выполнении шага.
	Data              interface{} // Данные ("переменные стэка горутины")
	LastCompletedStep string      // IP instruction pointer - последний выполненный шаг
}


// Наш линейный код представляем в виде пайплайна - последовательности шагов.
// Между этими шагами стейт пайплайн сохраняется в БД.
// По аналогии с горутинами: в определённых точках, расставленных компилятором, планировщик может взять горутину, сохранить
// её стейт и отправить на другой тред. Или вообще запарковать, если горутина сделала time.Sleep или ждёт ивентов.
// Как горутины выполняются на тредах, так и пайплайны выполняются на инстансах сервиса.
// Между шагами пайплайн можно запарковать при грейсфул шатдауне - выполнение перекинется на другой инстанс.
// Заснуть на какое-то время или пока не прийдёт событие.
//
// Например, если надо заснуть, то под капотом, джоба, выполняющая пайплайн, поставит следующую отложенную джобу и завершится.
