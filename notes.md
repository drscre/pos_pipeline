
Оговорить, где будем задавать вопросы.

* Проговорить логику словами (на слайде, где есть текст логики POS)

* Что будет, если мы начнём добавлять шаги в коде и деплоить
  - У нас синтаксический сахар для стейт-машины с линейным графом (неявная таблица переходов)
  - у шагов есть уникальные имена. Пайплайн запоминает

Код реализации обработчика webhook

### Мотивация поиска решения

Бизнес-логика POS - простая. И линейная!  
(В сравнении с тем-же GPM, где при попытке описать её словами будет очень много "если").

Линейность - это просто и понятно.  
Хочется выстроить уровни абстракции так, чтобы на верхнем уровне сохранить эту явную 
линейность. А нелинейные и технические детали убрать на уровни ниже. 

Пользоваться средставми выразительности языка программирования: формировать иерархические уровни абстракции: крупные блоки на верхнем уровне, детали пониже... 

(Как с большой теоремой Ферма: формулировка понятна школьнику, доказательство - единицам)

(Надо признаться - мы не хотим стейт-машину. Мы хотим флоу с чекпоинтами и ивентами)

(Например, я бы предлагаю рассматривать запросы к Зузу как асинхронные. Я отправил в Зуз запрос на создание авторизации, а потом мне событиями начинает 
приезжать результат. Как это реально реализовано, коллбэки и/или поллинг - это уже более детальный уровень.)

(Поэтому мне не очень нравится концепция стейт-машины, описывающей всё: теряется возможность пользоваться уровнями 
абстракции. Вся логика становится плоской и вытаскивается на один уровень.)

(В effe: assign_account_id (сходить в БД) - отдельный шаг, а целый поход в PMS за токеном карточки, который может
 зафейлиться или ругнуться на некорректный идентификатор карты - внутри шага createAuthorization вместе с походом в Зуз)
 
### Если бы был один неубиваемый инстанс POS 

### Откуда проблемы? 

1.  Несколько инстансов сервиса
    Инстансы могут запускаться, останавливаться и падать.

    "Пайплайн" обработки транзакции надо уметь перекидывать между инстансами  
    (примерно как планировщик Go перекидывает 
    горутины между тредами в заранее отведённых точках).
    
2.  Сервисы могут падать в любой момент. Пайплайн должен быть идемпотентный (внешние вызовы!). 
    
3.  Присутствует элемент асинхронщины: коллбэки от зуза.

### Точки "вызова планировщика"

1.  "time.Sleep" - когда мы хотим сделать паузу: например, повторить попытку позже.  
    Сделать следующий шаг с задержкой.

2.  Входящие событие - коллбэк от зуза.

### Особенности реализации

Хочется минимальное количество простых примитивов - шагов. После каждого шага можно делать чекпоинт.

Тут даже - о ужас - передаётся request по указателю в каждый шаг.

Локи вокруг шагов:
1) Чтобы ивент, заэмиченный из текущего шага, не потерялся а попал на следующий шаг, где его будут ждать 
2) чтобы одновременно не начать обрабатывать два разных ивента
3) Чем короче шаг - тем меньше таймаут детекта крэша джобы пайплайна (step lock ttl)

### Достоинства

В сравнении с effe, коллбэки включены в основной флоу

Индивидуальные RetryPolicy для шагов

Можем хранить историю выполнения (с подробностями типа количества ретраев на каждом шаге, ифов и т.д.)

### Вопросы
1) Необязательно пользоваться возвращением данных - но это удобно, тогда данные всегда будут консистентны с шагом пайплайна
